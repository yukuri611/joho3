/*
Copyright 2016 New System Vision Research and Development Institute.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef _FILTER_NxM_AXI_H_
#define _FILTER_NxM_AXI_H_


//#include "../../C2Rlib/include/typedef.h"
#include "filterNxM.hpp"

#include "../axi/axi4.h"

/**
NOTE on  FLT_REG_AXI4L.hpp:
FLT_REG_AXI4L.hpp is auto-generated by adding preprocessor macro RUN_C2R_CODE_GEN,
where the below code is executed:

C2R_CODE_GEN(CodeGenRegIF_AXI4L, cgen0, "FLT_REG_AXI4L", "template <typename CT, int CSIZE> ", regs);

regs : describes a set of registers for creating the memory-mapped register interface
std::vector<CodeGenRegIF_AXI4L::RegElement> regs = {
    { "reset",          1, 1, 0, 0 },   /// name, size (in bytes), elementCount, structFlag (optional: 0 by default)
    { "initialized",    1, 1, 0, 1 },
    { "width",          2, 1, 0, 0 },
    { "height",         2, 1, 0, 0 },
    { "coef",           "CT", 4, "CSIZE", 100, 1, 0 },    //// 4 is the maximum size, 100 is the maximum elementCount
    { "clip",           1, 1, 0, 0},
};

On Visual Studio : by selected "CodeGen" mode (instead of "Debug" or "Release"),
macro RUN_C2R_CODE_GEN is added, so "build & execute" on "CodeGen" mode will generate FLT_REG_AXI4L.hpp
**/

#if defined(RUN_C2R_CODE_GEN)
#include "../codeGen/codeGenRegIF.h"
std::vector<CodeGenRegIF_AXI4L::RegElement> regs = {
    /// name, size (in bytes), elementCount, signed, readOnly, structFlag (optional: 0 by default)
    { "reset",          1, 1, 0, 0 },
    { "initialized",    1, 1, 0, 1 },
    { "width",          2, 1, 0, 0 },
    { "height",         2, 1, 0, 0 },
    { "coef",           "CT", 4, "CSIZE", 100, 1, 0 },    //// 4 is the maximum size, 100 is the maximum elementCount
    { "clip",           1, 1, 0, 0},
};

C2R_CODE_GEN(CodeGenRegIF_AXI4L, cgen0, "FLT_REG_AXI4L", "template <typename CT, int CSIZE> ", regs);

#else

#include "FLT_REG_AXI4L.hpp"

template<typename T> struct PixCH {
    T data;
    BIT valid;
    PixCH() { reset(); }
    void set(T d, BIT v) { data = d; valid = v; }
    void reset() { valid = 0; data = 0; }
};

template <typename T, int FH, int FW> struct LineBufferRegWindow {
#if 0
    LineBufSimple<T, FH, MAX_IMG_WIDTH> lbuf;
#elif 1
    LineBufReadFirst<T, FH, MAX_IMG_WIDTH> lbuf;
#else
    LineBufInterleaved<T, FH, MAX_IMG_WIDTH> lbuf;
#endif
    ShiftRegWindow<T, FH, FW>  srw;
    void Init() { lbuf.Init(); srw.Init(); }
    BIT Update(PixCH<UINT32> &din, T sr1[], UINT32 height, UINT32 width) {   /// sr1[FH*FW]
        T lb1[FH];
        BIT lbvld[FH], srvld[FH*FW];
        int px = lbuf.stt.pos_x;
        lbuf.Update(din.data, lb1, width, height, lbvld, border001<T, FH>);
        srw.Update(lb1, lbvld, din.valid, sr1, srvld, px, width, border001<T, FH>);
        return srvld[FH*FW / 2];
    }
};

#define DBG_FIFO

template <typename T, int DEPTH> struct AXI_ST_FIFO {
    T buf[DEPTH] _TYPE(state);
    UINT8 rp _TYPE(state), wp _TYPE(state); /// rp : readPointer, wp : writePointer
    BIT full _TYPE(state), not_empty _TYPE(state), out_pending _TYPE(state);
    UINT32 cycle _TYPE(state);
    UINT8 maxDepth _TYPE(state);
    void Init() {
        full = 0; not_empty = 0; rp = 0; wp = 0;
        out_pending = 0;
#if defined(DBG_FIFO)
        maxDepth = 0;
        cycle++;
#endif
    }
    void Update(PixCH<UINT32> &din, PixCH<UINT32> &dout, BIT outReady) {
        int re = (not_empty && outReady);   /// re : readEnable
        int we = (!full && din.valid);      /// we : writeEnable
        out_pending = not_empty && !outReady;
        int nxt_rp = (rp + re == DEPTH) ? 0 : rp + re;
        int nxt_wp = (wp + we == DEPTH) ? 0 : wp + we;
#if defined(DBG_FIFO)
        UINT32 d = (wp >= rp) ? wp - rp : wp - rp + DEPTH;
        if (maxDepth < d) {
            printf("cycle[%6d] : d = %d\n", cycle, d);
            maxDepth = d;
        }
        cycle++;
#endif
        dout.data = buf[rp];
        dout.valid = not_empty;
        if (we) { buf[wp] = din.data; }
        rp = nxt_rp;
        wp = nxt_wp;
        if (re != we) {
            full      =  (we && nxt_rp == nxt_wp);
            not_empty = !(re && nxt_rp == nxt_wp);
        }
    }
};

//#define USE_C2R_MODULE

template <typename T, typename CT, int FH, int FW, int PIPE_COUNT> struct FLT_PRG_AXI /// programmable coefs
{
    FLT_REG_AXI4L<CT, FH*FW> reg;
    LineBufferRegWindow<T, FH, FW> lbw;
    AXI_ST_FIFO<T, PIPE_COUNT + 3> outFifo;
    BIT outPending;
    int Kernel(T *sr) {
        int sum = 0;
        for (int i = 0; i < FH*FW; i++) { sum += (int)sr[i] * (int)reg.coef[i]; }
        return ((sum >> 8) + ((sum >> 7) & 1)); /// round to even --> assumption is : sum is scaled by 8-bits
    }
    void UpdateRegIF(AXI4L::CH *axi_rif, BIT &init, BIT &curReady) {
        int reset = reg.reset;
        init = reset && !reg.initialized;
        curReady = reg.initialized && !outPending;
        reg.fsm(axi_rif);   /// fsm must be called every cycle
        if (reg.writeFlag) { reg.initialized = 0; }   /// if there is a write to reg, then clear reg.initialized
        else if (reset)    { reg.initialized = 1; }   /// if reg.reset == 1 (prev-cycle), then initialize at this cycle
    }
#if defined(USE_C2R_MODULE)
    _C2R_FUNC_T(PIPE_COUNT)
#endif
    void Step(AXI4L::CH *axi_rif, AXI_ST::CH *axi_in, AXI_ST::CH *axi_out) {
        /// AXI4L::CH *axi_rif;     /// axi4l register interface
        /// AXI_ST::CH *axi_in;     /// axi-stream input
        /// AXI_ST::CH *axi_out;    /// axi-stream output
        BIT init, curReady;
        UpdateRegIF(axi_rif, init, curReady);
        PixCH<UINT32> din, dout, dbuf;
        din.set(axi_in->m.data, axi_in->m.valid && curReady);
        axi_in->s.ready = curReady;
        outPending = outFifo.out_pending;
        if (init) {
            lbw.Init();
            outFifo.Init();
        }
        else {
            if (din.valid) {
                T sr1[FH*FW];
                dout.valid = lbw.Update(din, sr1, reg.height, reg.width);
                dout.data = (dout.valid) ? Kernel(sr1) : 0;
            }
            outFifo.Update(dout, dbuf, axi_out->s.ready);
        }
        axi_out->m.set(dbuf.data, dbuf.valid, 0);
    }
};
#endif

#endif /*_FILTER_NxM_AXI_H_*/
